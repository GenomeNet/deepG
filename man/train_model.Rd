% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/train.R
\name{train_model}
\alias{train_model}
\title{Train neural network on genomic data}
\usage{
train_model(
  train_type = "lm",
  model = NULL,
  path = NULL,
  path_val = NULL,
  dataset = NULL,
  dataset_val = NULL,
  path_checkpoint = NULL,
  path_log = NULL,
  train_val_ratio = 0.2,
  run_name = "run",
  batch_size = 64,
  epochs = 10,
  max_queue_size = 100,
  reduce_lr_on_plateau = TRUE,
  lr_plateau_factor = 0.9,
  patience = 20,
  cooldown = 1,
  steps_per_epoch = 1000,
  step = NULL,
  shuffle_file_order = TRUE,
  initial_epoch = 0,
  vocabulary = c("a", "c", "g", "t"),
  path_tensorboard = NULL,
  save_best_only = TRUE,
  save_weights_only = FALSE,
  seed = c(1234, 4321),
  shuffle_input = TRUE,
  tb_images = FALSE,
  format = "fasta",
  path_file_log = NULL,
  vocabulary_label = NULL,
  file_limit = NULL,
  reverse_complement = FALSE,
  reverse_complement_encoding = FALSE,
  output_format = "target_right",
  reset_states = FALSE,
  ambiguous_nuc = "equal",
  proportion_per_seq = NULL,
  read_data = FALSE,
  use_quality_score = FALSE,
  padding = FALSE,
  early_stopping_time = NULL,
  added_label_path = NULL,
  add_input_as_seq = NULL,
  target_from_csv = NULL,
  target_split = NULL,
  validation_only_after_training = FALSE,
  skip_amb_nuc = NULL,
  max_samples = NULL,
  split_seq = FALSE,
  class_weight = NULL,
  concat_seq = NULL,
  target_len = 1,
  print_scores = TRUE,
  train_val_split_csv = NULL,
  use_coverage = NULL,
  set_learning = NULL,
  proportion_entries = NULL,
  sample_by_file_size = FALSE,
  n_gram = NULL,
  n_gram_stride = 1,
  random_sampling = FALSE,
  add_noise = NULL
)
}
\arguments{
\item{train_type}{Either "lm", "lm_rds" for language model; "label_header", "label_folder", "label_csv", "label_rds" for classification or "dummy_gen".
Language model is trained to predict character in sequence.
"label_header"/"label_folder"/"label_csv" are trained to predict a corresponding class, given a sequence as input. If "label_header", class will be read from fasta headers.
If "label_folder", class will be read from folder, i.e. all files in one folder must belong to the same class.
If "label_csv", targets are read from a csv file. This file should have one column named "file". The targets then correspond to entries in that row (except "file"
column). Example: if we are currently working with a file called "a.fasta", there should be a row in our csv file
   file  |  label_1 | label_2
"a.fasta"     1          8
If "label_rds", generator will iterate over set of .rds files containing each a list of input and target tensors. Not implemented for model
with multiple inputs. If "lm_rds", generator will iterate over set of .rds files and will split tensor according to target_len argument
(targets are last target_len nucleotides of each sequence).
If "dummy_gen", generator creates random data once and repeatedly feeds these to model.}

\item{model}{A keras model.}

\item{path}{Path to folder where individual or multiple FASTA or FASTQ files are located for training. If \code{train_type} is \code{label_folder}, should be a vector or list
where each entry corresponds to a class. If \code{train_type} is not \code{label_folder}, can be a list of directories and/or single files.}

\item{path_val}{Path to folder where individual or multiple FASTA or FASTQ files are located for validation. If \code{train_type} is \code{label_folder}, should be a vector
containing a path for each class. If \code{train_type} is not \code{label_folder}, can be a list of directories and/or files.}

\item{dataset}{List of training data, holding training samples in RAM instead of using generator. Should be list with two entries called "X" and "Y".}

\item{dataset_val}{List of validation data. Should be list with two entries.}

\item{path_checkpoint}{Path to checkpoints folder or NULL. If NULL, checkpoints don't get stored.}

\item{path_log}{Path to directory to write training scores. File name is run_name + ".csv". No output if path_log is NULL.}

\item{train_val_ratio}{For generator, defines the fraction of batches that will be used for validation (compared to size of training data), i.e. one validtion iteration
processes \code{batch_size} x \code{steps_per_epoch} x \code{train_val_ratio} samples. If you use dataset instead of generator and \code{dataset_val} is NULL, splits \code{dataset}
into train/validation data.}

\item{run_name}{Name of the run. Name will be used to identify output from callbacks. If NULL, will use date as run name. If name already present, will add "_2" to name
or "_{x + 1}" if name ends with integer x.}

\item{batch_size}{Number of samples used for one network update.}

\item{epochs}{Number of iterations.}

\item{max_queue_size}{Queue on fit_generator().}

\item{reduce_lr_on_plateau}{Whether to use learning_rate scheduler.}

\item{lr_plateau_factor}{Factor of decreasing learning_rate when plateau is reached.}

\item{patience}{Number of epochs waiting for decrease in val_loss before reducing learning_rate.}

\item{cooldown}{Number of epochs without changing learning_rate.}

\item{steps_per_epoch}{Number of training batches per epoch.}

\item{step}{Frequency of sampling steps.}

\item{shuffle_file_order}{Boolean, whether to go through files sequentially or shuffle beforehand.}

\item{initial_epoch}{Epoch at which to start training. Note that network
will run for (\code{epochs} - \code{initial_epochs}) rounds and not \code{epochs} rounds.}

\item{vocabulary}{Vector of allowed characters. Character outside vocabulary get encoded as specified in \code{ambiguous_nuc}.}

\item{path_tensorboard}{Path to path_tensorboard directory or NULL. If NULL, training not tracked on tensorboard.}

\item{save_best_only}{Only save model that improved on best val_loss score.}

\item{save_weights_only}{Whether to save weights only.}

\item{seed}{Sets seed for set.seed function, for reproducible results.}

\item{shuffle_input}{Boolean, shuffle entries in file.}

\item{tb_images}{Boolean, whether to show plots in tensorboard.}

\item{format}{File format, "fasta" or "fastq".}

\item{path_file_log}{Write name of files used for training to csv file if path is specified.}

\item{vocabulary_label}{Character vector of possible targets. Targets outside \code{vocabulary_label} will get discarded if
\code{train_type = "label_header"}.}

\item{file_limit}{Use only specified number of files, ignored if greater than number of files in \code{path}.}

\item{reverse_complement}{Logical, for every new file decide randomly to use original data or its reverse complement.}

\item{reverse_complement_encoding}{Boolean, use both original sequence and reverse complement as two input sequences.}

\item{output_format}{Determines shape of output tensor for language model.
Either "target_right", "target_middle_lstm", "target_middle_cnn" or "wavenet".
Assume a sequence "AACCGTA". Output correspond as follows
"target_right": X = "AACCGT", Y = "A"
"target_middle_lstm": X = (X_1 = "AAC", X_2 = "ATG"), Y = "C" (note reversed order of X_2)
"target_middle_cnn": X = "AACGTA", Y = "C" 
"wavenet": X = "AACCGT", Y = "ACCGTA".}

\item{reset_states}{Boolean, whether to reset hidden states of RNN layer at every new input file and before/after validation.}

\item{ambiguous_nuc}{How to handle nucleotides outside vocabulary, either "zero", "discard", "empirical" or "equal". If "zero", input gets encoded as zero vector;
if "equal" input is 1/length(vocabulary) x length(vocabulary). If "discard" samples containing nucleotides outside vocabulary get discarded.
If "empirical" use nucleotide distribution of current file.}

\item{proportion_per_seq}{Numerical value between 0 and 1. Proportion of possible samples to take from one file. Takes samples from random subsequence.}

\item{read_data}{If true the first element of output is a list of length 2, each containing one part of paired read. Maxlen should be 2*length of one read.}

\item{use_quality_score}{Whether to use fastq qualitiy scores. If TRUE input is not one-hot-encoding but corresponds to probabilities.
For example (0.97, 0.01, 0.01, 0.01) instead of (1, 0, 0, 0).}

\item{padding}{Whether to pad sequences too short for one sample with zeros.}

\item{early_stopping_time}{Time in seconds after which to stop training.}

\item{added_label_path}{Path to folder with additional input labels. Should be a csv file with one column named "file". Other columns should correspond to one label.}

\item{add_input_as_seq}{Boolean vector specifying for each entry in \code{added_label_path} if rows from csv should be encoded as a sequence or used directly.
If a row in your csv file is a sequence this should be true. For example you may want to add another sequence, say ACCGT. Then this would correspond to 1,2,2,3,4 in
csv file (if vocabulary = c("A", "C", "G", "T")).  If \code{add_input_as_seq} is TRUE, 12234 gets one-hot encoded, so added input is a 3D tensor.  If \code{add_input_as_seq} is
FALSE this will feed network just raw data (a 2D tensor).}

\item{target_from_csv}{Path to csv file with target mapping. One column should be called "file" and other entries in row are the targets.}

\item{target_split}{If target gets read from csv file, list of names to devide target tensor into list of tensors.
Example: if csv file has header names "file", "label_1", "label_2", "label_3" und target_split = list(c("label_1", "label_2"), "label_3"),
this will devide target matrix to list of length 2, where the first element contains columns named "label_1" and "label_2" and the
second entry contains the column named "label_3".}

\item{validation_only_after_training}{Boolean, whether to skip validation during training and only do one validation after training.}

\item{skip_amb_nuc}{Threshold of ambiguous nucleotides to accept in fasta entry. Complete entry will get discarded otherwise.}

\item{max_samples}{Maximum number of samples to use from one file. If not NULL and file has more than \code{max_samples} samples, will randomly choose a
subset of \code{max_samples} samples.}

\item{split_seq}{Split input sequence into two sequences while removing nucleotide in middle. If input is x_1,..., x_(n+1), input gets split into
input_1 = x_1,..., x_m and input_2 = x_(n+1),..., x_(m+2) where m = ceiling((n+1)/2) and n = maxlen. Note that x_(m+1) is not used. Can be used for transfer learning,
when switching from language model trained with target in middle to label classification.}

\item{class_weight}{Named list of weights for output. For example: list("0" = 5, "1" = 0.8). Order should correspond to \code{vocabulary_label}.
You can use \code{get_class_weight} function to estimates class weights: class_weights <- get_class_weights(path = path, train_type = train_type)
If train_type = "label_csv" you need to add path to csv file:
class_weights <- get_class_weights(path = path, train_type = train_type, csv_path = target_from_csv)}

\item{concat_seq}{Character string or NULL. If not NULL all entries from file get concatenated to one sequence with concat_seq string between them.
Example: If 1.entry AACC, 2. entry TTTG and concat_seq = "ZZZ" this becomes AACCZZZTTTG.}

\item{target_len}{Number of nucleotides to predict at once.}

\item{print_scores}{Whether to print train/validation scores during training.}

\item{train_val_split_csv}{A csv file specifying train/validation split. csv file should contain one column named "file" and one columnn named
"type". The "file" column contains names of fasta/fastq files and "type" column specifies if file is used for training or validation.
Entries in "type" must be named "train" or "val", otherwise file will not be used for either. path and path_val arguments should be the same.
Not implemented for train_type = "label_folder".}

\item{use_coverage}{Integer or NULL. If not NULL, use coverage as encoding rather than one-hot encoding and normalize .}

\item{set_learning}{When you want to assign one label to set of samples. Only implemented for train_type = "label_folder".
Input is a list with the following parameters
(1) \code{samples_per_target}, how many samples to use for one target; (2) \code{maxlen} length of one sample
(3) \code{reshape_mode} "time_dist", "multi_input" or "concat". If reshape_mode is "concat", there is an additional (4) \code{buffer_len}
argmument. If reshape_mode is "multi_input", generator will produce samples_per_target separate inputs, each of length maxlen (model should have
samples_per_target input layers). If reshape_mode is "time_dist", generator will produce a 4D input array. The dimensions correspond to
(batch_size, samples_per_target, maxlen, length(vocabulary)). If reshape mode is "concat", generator will concatenate samples_per_target sequences
of length maxlen to one long sequence; if buffer_len is an integer, the subsequences are interspaced with buffer_len rows. The input length is
(maxlen \* samples_per_target) + buffer_len \* (samples_per_target - 1)}

\item{proportion_entries}{Proportion of fasta entries to keep. For example, if fasta file has 50 entries and proportion_entries = 0.1,
will randomly select 5 entries.}

\item{sample_by_file_size}{Sample new file weighted by file size (possible to repeatedly sample the same file).}

\item{n_gram}{Encode n nucleotides at once. Can be used for language model for target encoding (not input yet)
or for input sequence for label training.}

\item{n_gram_stride}{Step size for n-gram encoding. For AACCGGTT with n-gram = 4 and n_gram_stride = 2, generator encodes
(AACC), (CCGG), (GGTT); for n_gram_stride = 4 generator encodes (AACC), (GGTT).}

\item{add_noise}{NULL or list of arguments. If not NULL, list must contain the following arguments: \code{noise_type} can be "normal" or "uniform";
optional arguments sd or mean if noise_type is "normal" (default is sd=1 and mean=0) or min, max if noise_type is "uniform"
(default is min=0, max=1).}
}
\description{
Train a neural network on genomic data. Data can be fasta/fastq files, rds files or a prepared data set.
If the data is given as collection of fasta, fastq or rds files, function will create a data generator that extracts training and validation batches
from files. Functions includes several options to detemine the sampling strategy of the generetor and preprocessing of the data.  
Training progress can be visualized in tensorboard. Model weights can be stored during training using checkpoints.
}
\examples{
\dontrun{
# create dummy data
path_train_1 <- tempfile()
path_train_2 <- tempfile()
path_val_1 <- tempfile()
path_val_2 <- tempfile()

for (current_path in c(path_train_1, path_train_2,
                       path_val_1, path_val_2)) {
  dir.create(current_path)
  create_dummy_data(file_path = current_path,
                    num_files = 3,
                    seq_length = 10,
                    num_seq = 5,
                    vocabulary = c("a", "c", "g", "t"))
}

# create model
model <- create_model_lstm_cnn(layer_lstm = 8, layer_dense = 2, maxlen = 5)

# train model
hist <- train_model(train_type = "label_folder",
                    model = model,
                    path = c(path_train_1, path_train_2),
                    path_val = c(path_val_1, path_val_2),
                    batch_size = 8,
                    epochs = 3,
                    steps_per_epoch = 6,
                    step = 5,
                    format = "fasta",
                    path_file_log = NULL,
                    vocabulary_label = c("label_1", "label_2"))
}                     
}
