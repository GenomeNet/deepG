% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preprocess.R
\name{seq_encoding_label}
\alias{seq_encoding_label}
\title{Encodes integer sequence for label classification.}
\usage{
seq_encoding_label(
  sequence = NULL,
  maxlen,
  vocabulary,
  start_ind,
  ambiguous_nuc = "zero",
  nuc_dist = NULL,
  quality_vector = NULL,
  use_coverage = FALSE,
  max_cov = NULL,
  cov_vector = NULL,
  n_gram = NULL,
  n_gram_stride = 1,
  masked_lm = NULL,
  char_sequence = NULL,
  tokenizer = NULL,
  adjust_start_ind = FALSE,
  return_int = FALSE
)
}
\arguments{
\item{sequence}{Sequence of integers.}

\item{maxlen}{Length of predictor sequence.}

\item{vocabulary}{Vector of allowed characters. Characters outside vocabulary get encoded as specified in \code{ambiguous_nuc}.}

\item{start_ind}{Start positions of samples in \code{sequence}.}

\item{ambiguous_nuc}{How to handle nucleotides outside vocabulary, either \code{"zero"}, \code{"empirical"} or \code{"equal"}.
See \code{\link{train_model}}. Note that \code{"discard"} option is not available for this function.}

\item{nuc_dist}{Nucleotide distribution.}

\item{quality_vector}{Vector of quality probabilities.}

\item{use_coverage}{Integer or \code{NULL}. If not \code{NULL}, use coverage as encoding rather than one-hot encoding and normalize.
Coverage information must be contained in fasta header: there must be a string \code{"cov_n"} in the header, where \code{n} is some integer.}

\item{max_cov}{Biggest coverage value. Only applies if \code{use_coverage = TRUE}.}

\item{cov_vector}{Vector of coverage values associated to the input.}

\item{n_gram}{Integer, encode target not nucleotide wise but combine n nucleotides at once. For example for \verb{n=2, "AA" ->  (1, 0,..., 0),}
\verb{"AC" ->  (0, 1, 0,..., 0), "TT" -> (0,..., 0, 1)}, where the one-hot vectors have length \code{length(vocabulary)^n}.}

\item{n_gram_stride}{Step size for n-gram encoding. For AACCGGTT with \code{n_gram = 4} and \code{n_gram_stride = 2}, generator encodes
\verb{(AACC), (CCGG), (GGTT)}; for \code{n_gram_stride = 4} generator encodes \verb{(AACC), (GGTT)}.}

\item{masked_lm}{If not \code{NULL}, input and target are equal except some parts of the input are masked or random.
Must be list with the following arguments:
\itemize{
\item \code{mask_rate}: Rate of input to mask (rate of input to replace with mask token).
\item \code{random_rate}: Rate of input to set to random token.
\item \code{identity_rate}: Rate of input where sample weights are applied but input and output are identical.
\item \code{include_sw}: Whether to include sample weigths.
\item \code{block_len} (optional): Masked/random/identity regions appear in blocks of size \code{block_len}.
}}

\item{char_sequence}{A character string.}

\item{tokenizer}{A keras tokenizer.}

\item{adjust_start_ind}{Whether to shift values in \code{start_ind} to start at 1: for example (5,11,25) becomes (1,7,21).}

\item{return_int}{Whether to return integer encoding or one-hot encoding.}
}
\description{
Returns encoding for integer or character sequence.
}
\examples{
# use integer sequence as input
x <- seq_encoding_label(sequence = c(1,0,5,1,3,4,3,1,4,1,2),
                        maxlen = 5,
                        vocabulary = c("a", "c", "g", "t"),
                        start_ind = c(1,3),
                        ambiguous_nuc = "equal")

x[1,,] # 1,0,5,1,3

x[2,,] # 5,1,3,4,

# use character string as input
x <- seq_encoding_label(maxlen = 5,
                        vocabulary = c("a", "c", "g", "t"),
                        start_ind = c(1,3),
                        ambiguous_nuc = "equal",
                        char_sequence = "ACTaaTNTNaZ")

x[1,,] # actaa

x[2,,] # taatn
}
