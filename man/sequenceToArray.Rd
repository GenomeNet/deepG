% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preprocess.R
\name{sequenceToArray}
\alias{sequenceToArray}
\title{One-hot-encodes integer sequence}
\usage{
sequenceToArray(
  sequence,
  maxlen,
  vocabulary,
  startInd,
  wavenet_format = FALSE,
  target_middle = FALSE,
  ambiguous_nuc = "zero",
  nuc_dist = NULL,
  use_quality = FALSE,
  quality_vector = NULL,
  cnn_format,
  target_len = 1,
  use_coverage = FALSE,
  cov_vector = NULL,
  n_gram = NULL,
  n_gram_stride = 1
)
}
\arguments{
\item{sequence}{Sequence of integers.}

\item{maxlen}{Length of one sample}

\item{vocabulary}{Set of characters to encode.}

\item{startInd}{Start positions of samples in \code{sequence}.}

\item{wavenet_format}{Boolean.}

\item{target_middle}{Boolean, target is in middle of sequence.}

\item{ambiguous_nuc}{How to handle nucleotides outside vocabulary, either "zero", "discard" or "equal". If "zero", input gets encoded as zero vector; 
if "equal" input is 1/length(vocabulary) x length(vocabulary). If "discard" samples containing nucleotides outside vocabulary get discarded.}

\item{nuc_dist}{Nucleotide distribution.}

\item{use_quality}{Use quality scores.}

\item{quality_vector}{Vector of quality probabilities.}

\item{cnn_format}{Boolean. If true, nucleotides on the left and right side of the predicted nucleotide (language model) are 
concatenated in the first layer, which make the structure more suitable to CNN architectures (without RNN).}
}
\description{

}
