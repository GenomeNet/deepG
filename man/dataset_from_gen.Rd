% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generators.R
\name{dataset_from_gen}
\alias{dataset_from_gen}
\title{Collect samples from generator and store in rds file.}
\usage{
dataset_from_gen(
  output_path,
  num_samples = 1000,
  train_type = "lm",
  output_format = "target_right",
  path,
  format = "fasta",
  maxlen = 250,
  vocabulary = c("a", "c", "g", "t"),
  seed = 1234,
  reverseComplements = FALSE,
  ambiguous_nuc = "zeros",
  use_quality_score = FALSE,
  padding = FALSE,
  added_label_path = NULL,
  add_input_as_seq = NULL,
  skip_amb_nuc = NULL,
  concat_seq = NULL,
  target_len = 1,
  use_coverage = FALSE,
  reshape_mode = NULL,
  set_learning = NULL
)
}
\arguments{
\item{output_path}{Where to store output rds file.}

\item{output_format}{Determines shape of output tensor for language model.
Either "target_right", "target_middle_lstm", "target_middle_cnn" or "wavenet".
Assume a sequence "AACCGTA". Output correspond as follows
"target_right": X = "AACCGT", Y = "A"
"target_middle_lstm": X = (X_1 = "AAC", X_2 = "ATG"), Y = "C" (note reversed order of X_2)
"target_middle_cnn": X = "AACGTA", Y = "C" 
"wavenet": X = "AACCGT", Y = "ACCGTA"}

\item{path}{Path}

\item{format}{File format, either fasta or fastq.}

\item{maxlen}{Length of predictor sequence.}

\item{vocabulary}{Vector of allowed characters, character outside vocabulary get encoded as 0-vector.}

\item{seed}{Sets seed for set.seed function, for reproducible results when using \code{randomFiles} or \code{shuffleFastaEntries}}

\item{reverseComplements}{Logical, for every new file decide randomly to use original data or its reverse complement.}

\item{ambiguous_nuc}{How to handle nucleotides outside vocabulary, either "zero", "discard", "empirical" or "equal". If "zero", input gets encoded as zero vector; 
if "equal" input is 1/length(vocabulary) x length(vocabulary). If "discard" samples containing nucleotides outside vocabulary get discarded. 
If "empirical" use nucleotide distribution of current file.}

\item{use_quality_score}{Whether to use fastq qualitiy scores. If TRUE input is not one-hot-encoding but corresponds to probabilities.
For example (0.97, 0.01, 0.01, 0.01) instead of (1, 0, 0, 0).}

\item{padding}{Whether to pad sequences too short for one sample with zeros.}

\item{added_label_path}{Path to folder with additional labels. Should be a csv file with one column named "file". Other columns should correspond to one label.}

\item{add_input_as_seq}{Boolean vector specifying for each entry in \code{added_label_path} if rows from csv should be encoded as a sequence or used directly.
If a row in your csv file is a sequence this should be true. For example you may want to add another sequence, say ACCGT. Then this would correspond to 1,2,2,3,4 in
csv file (if vocabulary = c("A", "C", "G", "T")).  If \code{add_input_as_seq} is TRUE, 12234 gets one-hot encoded, so added input is a 3D tensor.  If \code{add_input_as_seq} is 
FALSE this will feed network just raw data (a 2D tensor).}

\item{skip_amb_nuc}{Threshold of ambiguous nucleotides to accept in fasta entry. Complete entry will get discarded otherwise.}

\item{concat_seq}{Character string or NULL. If not NULL all entries from file get concatenated to one sequence with concat_seq string between them.
Example: If 1.entry AACC, 2. entry TTTG and concat_seq = "ZZZ" this becomes AACCZZZTTTG.}

\item{target_len}{Number of nucleotides to predict at once.}

\item{use_coverage}{Boolean. Whether to use coverage as encoding rather than one-hot encoding.}
}
\description{
Repeatedly take one random sample from random file and combine samples. Files are sampled weighted by file size.
}
